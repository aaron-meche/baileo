const { asUTF8:t, toHEX:n } = require('worktop/buffer');function e(e,r){return crypto.subtle.digest(e,t(r)).then(n)}var r=e.bind(0,"MD5"),i=e.bind(0,"SHA-1"),u=e.bind(0,"SHA-256"),o=e.bind(0,"SHA-384"),b=e.bind(0,"SHA-512");function s(n,e,r){return crypto.subtle.importKey("raw",t(e),n,!1,r)}function c(t,n,e=!1){return crypto.subtle.generateKey(t,e,n)}function f(n,e,r){return crypto.subtle.sign(n,e,t(r))}function a(n,e,r,i){return crypto.subtle.verify(n,e,i,t(r))}function y(t,n){if(t.byteLength!==n.byteLength)return!1;let e=t.length,r=!1;for(;e-- >0;)t[e]!==n[e]&&(r=!0);return!r}async function d(n,e,r,i,u){const o=await s("PBKDF2",e,["deriveBits"]),b={name:"PBKDF2",salt:t(r),iterations:i,hash:n};return crypto.subtle.deriveBits(b,o,u<<3)}function p(t,n,e){return s({name:"HMAC",hash:t},n,["sign"]).then((t=>f("HMAC",t,e)))}var h=p.bind(0,"SHA-256"),l=p.bind(0,"SHA-384"),A=p.bind(0,"SHA-512");exports.HMAC=p;exports.HMAC256=h;exports.HMAC384=l;exports.HMAC512=A;exports.MD5=r;exports.PBKDF2=d;exports.SHA1=i;exports.SHA256=u;exports.SHA384=o;exports.SHA512=b;exports.digest=e;exports.keygen=c;exports.keyload=s;exports.sign=f;exports.timingSafeEqual=y;exports.verify=a;