import{asUTF8 as t,toHEX as n}from"worktop/buffer";function e(e,r){return crypto.subtle.digest(e,t(r)).then(n)}var r=e.bind(0,"MD5"),i=e.bind(0,"SHA-1"),u=e.bind(0,"SHA-256"),o=e.bind(0,"SHA-384"),b=e.bind(0,"SHA-512");function s(n,e,r){return crypto.subtle.importKey("raw",t(e),n,!1,r)}function c(t,n,e=!1){return crypto.subtle.generateKey(t,e,n)}function f(n,e,r){return crypto.subtle.sign(n,e,t(r))}function a(n,e,r,i){return crypto.subtle.verify(n,e,i,t(r))}function y(t,n){if(t.byteLength!==n.byteLength)return!1;let e=t.length,r=!1;for(;e-- >0;)t[e]!==n[e]&&(r=!0);return!r}async function d(n,e,r,i,u){const o=await s("PBKDF2",e,["deriveBits"]),b={name:"PBKDF2",salt:t(r),iterations:i,hash:n};return crypto.subtle.deriveBits(b,o,u<<3)}function p(t,n,e){return s({name:"HMAC",hash:t},n,["sign"]).then((t=>f("HMAC",t,e)))}var h=p.bind(0,"SHA-256"),l=p.bind(0,"SHA-384"),A=p.bind(0,"SHA-512");export{p as HMAC,h as HMAC256,l as HMAC384,A as HMAC512,r as MD5,d as PBKDF2,i as SHA1,u as SHA256,o as SHA384,b as SHA512,e as digest,c as keygen,s as keyload,f as sign,y as timingSafeEqual,a as verify};